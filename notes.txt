612
19-487-172
http://86.119.43.169:9090


function keyword
--------------------------------

keyword: function

function name(parameters) { 
					statements;
				  	return stuff;
				}

calling function: name(arguments);

When the function has no parameters the given argument gets ignored

There is NO function overloading in JS! It takes the last function declared.

No return statememnt means NO return in JS
const func = () => 1; // automaticaly adds return statements

const name = () => {statements;} // Lambda
=> is a replacememnt of function keyword
(input) => (function) // returns function, therefore can be given a name 

functions can be in an array:
const funs = [null, fun1, fun2];
funs[2]() // is fun2()

passing function to function --> higher order function


        function doit(whatToDo) {
            return function bla(arg) { return whatToDo(arg); }
        }

        is same as:

        const doit2 = callme => arg => callme(arg) ;
        
     	the curryied style:
     	passing arguments step by step
     	const example = doit2(fun1)(10);

--------------------------------
Console
--------------------------------


console.dir(); //gives more information
console.table([{x:1, y:2}, {x:2, y:4}]); // table overview

--------------------------------
Scopes
--------------------------------

global scope:
window (browser)

function scope:
variables are local to enclosing function


x = ... // mutable, global scope --> DO NOT USE THIS!
var x = ... // mutable "hoisted" scope --> DO NOT USE
let x = ... // mutable, local scope
const x = ... // immutabe, local scope

general, in scope after first use!

var x = ... puts x not where you expect, it is hoisted, means it gets defined at the beginning of your script. Even when code is never reached, the var is defined, dnagerous!

use let x = ... and const x = ...

even if you want to chnage the x later on, start with const x = ...
the value can change, ex. array elements can still be changed
you do const x = 3; and then let x = 5; therefore oyu can change it afterwards

Structure and Interpretation of Computer Programs (Book)

--------------------------------
Immediately Invoked Function Expression [IIFE]
--------------------------------

function foo() {...}; foo();
In the end lamba was born, that can be immediately invoked:
(() => {...})();

--------------------------------
Lambda
--------------------------------

Everything that can be calulated with calulus, can be calulated with Lambda

Three Operations possible:
- Rename parameter (alpha)
- Apply argument (beta)
- Cancle paramter (eta)

eta reduktion:
x => y => plus(x)(y)
x => plus(x)
plus

--------------------------------
Logging
--------------------------------
const logAll = () => {
    console.error("error", longRunning("error"));
}

Siehe Repo week3/GoodieConsoleLogLevel.html



--------------------------------
Higher Order Functions
--------------------------------

Utiliti function in toolbox, to find if id is in document or not

--------------------------------
JS-Doc
--------------------------------

Mittels JavaDoc kann man darauf hinweisen welcher Typ die Variable aben soll. 
Ist aber OPTIONAL, becuase fuck types am I right? (I want my C back...)

/**
*
* @type { String }
*/
const a = "hello";
console.log(a);
a = 0; / <--- hier wird warnung augegeben wegen Int zu String


Parameter x ist OK mit String und Number aber nur Strign welche "Hello" ist

/**
* Doc eintrag für foo()
* 
* @param { String | Number | "Hello" } x - Doc eintrag für x
*/
const foo = x => console.log(x);
foo("hi");
foo(0);
foo(true); // <-- Warung hier
foo("hallo"); // <-- Warung da nicht "Hello"

--------------------------------
Higher Order Function
--------------------------------
===map
const times = a => b => a*b;
const twoTimes = times(2);

[1, 2, 3].map(x => times(2)(x)); // Beta reduction führt zu times(2)
[1, 2, 3].map(times(2)); // times(2) ist twoTimes
[1, 2, 3].map(twoTimes);

Map gibt immer gleichen typ zurück welcher als input genutzt wurde
Inner Type kann wechseln (z.B. int to string), äusserer bleibt gleich, array bleibt array

===filter
function we apply need to be a boolean, where true, his value will get chosen --> filtered
here number of entrie change

const odd = x => x % 1 === 1;
[1, 2, 3].filter(x = x % 2 === 1);
[1, 2, 3].filter(x => odd(x));
[1, 2, 3].filter(odd);

===reduce
reduce((acc, cur) => acc + cur); 
[1,2,3] -> [3,3] ->  [3]

result of reduce is always inner type

const plus = (accu, cur) => accu + cur;
[1, 2, 3].reduce((accu, cur) => accu + cur);
[1, 2, 3].reduce(plus);
[1, 2, 3].reduce(plus, 0); // here you give a start element, so you do strart with a 0 and 1, not 1 and 2 (good practice), good when array is empty

===Monoid
pair + pair == pair
n + _ = n;
_ + n = n;

example:
"x" + "y" = "xy"; // is a monoid because result is a String, so string concat is a monoid (assiozativ)

usefull to limit operations needed, example:
1+2+3+4+5 --> because monoid we can do (1+2)+(3+4)+5, makes it easier and more efficient

===functor
map (f) (pair) == pair;


--------------------------------

--------------------------------


--------------------------------

--------------------------------


--------------------------------

--------------------------------


--------------------------------

--------------------------------
